#!/usr/bin/env python
#
# Copyright (c) 2011, Yubico AB
# All rights reserved.
#

import os
import sys
import BaseHTTPServer
import argparse
import syslog
import re
sys.path.append('Lib');
import pyhsm
import pyhsm.yubikey
import serial

default_device = "/dev/ttyACM0"
default_dir = "/dev/shm/yubico/secrets"
default_serve_url = "/yhsm/validate?"

ykotp_valid_input = re.compile('^[cbdefghijklnrtuv]{32,48}$')

hsm = None
args = None
saved_key_handle = None

class YHSM_KSMRequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):

    def do_GET(self):
        # Example session:
        # in  : GET /wsapi/decrypt?otp=ftftftccccdvvbfcfduvvcubikngtchlubtutucrld HTTP/1.0
        # out : OK counter=0004 low=f585 high=3e use=03
        global args
        if self.path.startswith(args.serve_url):
            res = None
            mode = None
            cmd = self.path[len(args.serve_url):]
            if cmd.startswith("otp=") and args.mode_otp:
                # YubiKey OTP
                mode = 'YubiKey OTP'
                res = validate_yubikey_otp(self, cmd[4:])
            elif cmd.startswith("oath=") and args.mode_oath:
                mode = 'OATH'
                res = validate_oath(self, cmd[5:])
            elif cmd.startswith("pwhash=") and args.mode_pwhash:
                mode = 'Password hash'
                res = validate_pwhash(self, cmd[7:])

            self.log_message("%s validation result: %s -> %s", mode, cmd, res)

            if res != None:
                self.send_response(200)
                self.send_header('Content-type', 'text/html')
                self.end_headers()
                self.wfile.write(res)
                self.wfile.write("\n")
            else:
                self.log_error ("No validation result to '%s' (responding 403)" % (self.path))
                self.send_response(403, 'Forbidden')
                self.end_headers()
        else:
            self.log_error ("Bad URL '%s' - I'm serving '%s' (responding 403)" % (self.path, args.serve_url))
            self.send_response(403, 'Forbidden')
            self.end_headers()

    def log_error(self, format, *fmt_args):
        """ Log to syslog. """
        global args
        msg = self.my_address_string() + " - - " + format % fmt_args
        my_log_message(args, syslog.LOG_ERR, msg)

    def log_message(self, format, *fmt_args):
        """ Log to syslog. """
        global args
        msg = self.my_address_string() + " - - " + format % fmt_args
        my_log_message(args, syslog.LOG_INFO, msg)

    def my_address_string(self):
        """ For logging client host without resolving. """
        return self.client_address[0]

def validate_yubikey_otp(self, from_key):
    """
    Validate YubiKey OTP using YubiHSM internal database.
    """
    global ykotp_valid_input
    if not re.match(ykotp_valid_input, from_key):
        self.log_error("IN: %s, Invalid OTP" % (from_key))
        return "ERR Invalid OTP"
    global hsm
    try:
        res = pyhsm.yubikey.validate_otp(hsm, from_key)
        return "OK counter=%04x low=%04x high=%02x use=%02x" % \
            (res.use_ctr, res.ts_low, res.ts_high, res.session_ctr)
    except pyhsm.exception.YHSM_CommandFailed, e:
        return "ERR %s" % (pyhsm.defines.status2str(e.status))

def validate_oath(self, from_key):
    """
    Validate OATH code using YubiHSM HMAC-SHA1 hashing.
    """
    return "ERR Not implemented"

def validate_pwhash(self, from_key):
    """
    Validate password hash using YubiHSM.
    """
    return "ERR Not implemented"


def parse_args():
    """
    Parse the command line arguments
    """
    global default_device
    global default_serve_url

    parser = argparse.ArgumentParser(description = "Generate secrets using YubiHSM",
                                     add_help=True
                                     )
    parser.add_argument('-D', '--device',
                        dest='device',
                        default=default_device,
                        required=False,
                        help='YubiHSM device (default : "%s").' % default_device
                        )
    parser.add_argument('-B', '--aead-dir',
                        dest='aead_dir',
                        default=default_dir,
                        required=False,
                        help='Aead directory - base directory of your aeads (default : "%s").' % default_dir
                        )
    parser.add_argument('-U', '--serve-url',
                        dest='serve_url',
                        default=default_serve_url,
                        required=False,
                        help='Base URL for decrypt web service (default : "%s").' % default_serve_url
                        )
    parser.add_argument('-v', '--verbose',
                        dest='verbose',
                        action='store_true', default=False,
                        help='Enable verbose operation.'
                        )
    parser.add_argument('--debug',
                        dest='debug',
                        action='store_true', default=False,
                        help='Enable debug operation.'
                        )
    parser.add_argument('--port',
                        dest='listen_port',
                        type=int, default=8003,
                        required=False,
                        help='Port to listen on.'
                        )
    parser.add_argument('--addr',
                        dest='listen_addr',
                        default="127.0.0.1",
                        required=False,
                        help='Address to bind to.'
                        )
    parser.add_argument('--hmac-kh',
                        dest='hmac_kh',
                        required=False, default=0,
                        help='Key handle to use for creating HMAC-SHA1 hashes.'
                        )
    parser.add_argument('--otp',
                        dest='mode_otp',
                        action='store_true', default=False,
                        help='Enable YubiKey OTP validation.'
                        )
    parser.add_argument('--oath',
                        dest='mode_oath',
                        action='store_true', default=False,
                        help='Enable OATH-HOTP validation.'
                        )
    parser.add_argument('--pwhash',
                        dest='mode_pwhash',
                        action='store_true', default=False,
                        help='Enable password hash validation.'
                        )

    return parser.parse_args()

def args_fixup(args):
    if not os.path.isdir(args.aead_dir):
        my_log_message(args, syslog.LOG_ERR, "Aead directory '%s' does not exist." % (args.aead_dir))
        sys.exit(1)

    global saved_key_handle
    saved_key_handle = args.hmac_kh

    args.key_handle = pyhsm.util.key_handle_to_int(args.hmac_kh)


def run(args):
    server_address = (args.listen_addr, args.listen_port)
    httpd = BaseHTTPServer.HTTPServer(server_address, YHSM_KSMRequestHandler)
    global saved_key_handle
    my_log_message(args, syslog.LOG_INFO, "Serving requests to 'http://%s:%s%s' (YubiHSM: '%s')" \
                       % (args.listen_addr, args.listen_port, args.serve_url, args.device))
    httpd.serve_forever()

def my_log_message(args, prio, msg):
    syslog.syslog(prio, msg)
    if args.debug or args.verbose or prio == syslog.LOG_ERR:
        sys.stderr.write("%s\n" % (msg))

def main():
    my_name = os.path.basename(sys.argv[0])
    if not my_name:
        my_name = "yhsm-validation-server"
    syslog.openlog(my_name, syslog.LOG_PID, syslog.LOG_LOCAL0)

    global args
    args = parse_args()
    args_fixup(args)

    global hsm
    try:
        hsm = pyhsm.YHSM(device = args.device, debug = args.debug)
    except serial.SerialException, e:
        my_log_message(args, syslog.LOG_ERR, 'Failed opening YubiHSM device "%s" : %s' %(args.device, e))
        sys.exit(1)

    try:
        run(args)
    except KeyboardInterrupt:
        print ""
        print "Shutting down"
        print ""

if __name__ == '__main__':
    main()
