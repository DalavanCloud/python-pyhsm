#!/usr/bin/env python
"""
Tool to program a YubiKey for validation using the internal database of
a YubiHSM.
"""
#
# Copyright (c) 2011, Yubico AB
# All rights reserved.
#
import sys
sys.path.insert(0, '/home/ft/work/yubico/python/python-yubico/Lib')

import os
import sys
import argparse
import pyhsm
import struct
import yubico

default_device = "/dev/ttyACM0"

def parse_args():
    """
    Parse the command line arguments
    """
    global default_device

    parser = argparse.ArgumentParser(description = "Configure YubiKey's for use with YubiHSM",
                                     add_help = True,
                                     formatter_class = argparse.ArgumentDefaultsHelpFormatter,
                                     )
    parser.add_argument('-D', '--device',
                        dest='device',
                        default=default_device,
                        required=False,
                        help='YubiHSM device'
                        )
    parser.add_argument('-v', '--verbose',
                        dest='verbose',
                        action='store_true', default=False,
                        help='Enable verbose operation'
                        )
    parser.add_argument('--debug',
                        dest='debug',
                        action='store_true', default=False,
                        help='Enable debug operation'
                        )
    parser.add_argument('-c', '--count',
                        dest='count',
                        type=int, default=1,
                        required=False,
                        help='Number of YubiKey\'s to configure',
                        )
    parser.add_argument('-1',
                        dest='slot_1',
                        action='store_true', default=False,
                        help='Configure YubiKey slot 1 (may be used in combination with -2)'
                        )
    parser.add_argument('-2',
                        dest='slot_2',
                        action='store_true', default=False,
                        help='Configure YubiKey slot 2 (may be used in combination with -1)'
                        )
    parser.add_argument('--public-id',
                        dest='public_id',
                        required=True,
                        help='The first YubiKey public id to use',
                        )
    parser.add_argument('--key-handle',
                        dest='key_handle',
                        required=True,
                        help='Key handle to create AEAD.'
                        )

    args = parser.parse_args()

    try:
        n = int(args.public_id)
    except ValueError:
        hexstr = pyhsm.yubikey.modhex_decode(args.public_id)
        n = int(hexstr, 16)
    if n > 0x0000ffffffffffff:
        sys.stderr.write("Public ID too large (won't fit in 6 bytes)\n")
        return None
    args.public_id = n

    args.key_handle = pyhsm.util.key_handle_to_int(args.key_handle)

    return args

def program_yubikeys(args):
    """ Main loop for programming the requested number of keys. """
    public_id = args.public_id
    num_yubikeys = yubikeys_needed(args)
    for i in xrange(num_yubikeys):
        raw_input("Insert YubiKey #%i/%i and press enter..." % (i + 1, num_yubikeys))
        YK = yubico.find_yubikey(debug = args.debug)
        serial = "unknown"
        version = YK.version()
        try:
            serial = "%i" % (YK.serial())
        except yubico.yubico_exception.YubicoError:
            # don't require serial number to be API readable
            pass
        print "  Programming YubiKey version %s with serial %s" % (version, serial)
        public_id = program_slot(args.slot_1, 1, public_id, args, YK)
        if public_id < args.public_id + args.count:
            if args.slot_1 and args.slot_2:
                raw_input("Press enter again to program slot 2...")
            public_id = program_slot(args.slot_2, 2, public_id, args, YK)

def program_slot(will_use, slot, public_id, args, YK):
    """ Program a slot, if will_use is true. """
    if not will_use:
        return public_id
    modhex_id = pyhsm.yubikey.modhex_encode("%012x" % public_id)

    # re-initialize YubiHSM for each slot we are programming, in case
    # someone wants to get secrets into multiple YubiHSM:s (like for
    # programming admin-YubiKeys into a bunch of YubiHSM:s)
    hsm = pyhsm.YHSM(device = args.device, debug=args.debug)
    nonce = struct.pack('>Q', public_id).rjust(pyhsm.defines.YSM_PUBLIC_ID_SIZE, chr(0x0))[2:8]

    # Get random data from YubiHSM
    rnd = hsm.random(pyhsm.defines.YSM_PUBLIC_ID_SIZE + pyhsm.defines.YSM_OTP_SIZE)
    private_uid = rnd[:pyhsm.defines.YSM_PUBLIC_ID_SIZE]
    aes_key = rnd[pyhsm.defines.YSM_PUBLIC_ID_SIZE:]
    secret = pyhsm.aead_cmd.YHSM_YubiKeySecret(aes_key, private_uid)
    # turn it into an AEAD
    aead = hsm.generate_aead_simple(nonce, args.key_handle, secret.pack())

    # Create YubiKey config
    Cfg = YK.init_config()
    Cfg.extended_flag('SERIAL_API_VISIBLE', True)
    Cfg.fixed_string('m:' + modhex_id)
    Cfg.mode_yubikey_otp(private_uid, aes_key)

    # Program YubiKey
    YK.write_config(Cfg, slot = slot)
    # Load AEAD into YubiHSM internal database
    hsm.db_store_yubikey(nonce, args.key_handle, aead)
    if args.verbose or args.debug:
        print "    slot %i - %s,%s,%s" % (slot, modhex_id, private_uid.encode('hex'), aes_key.encode('hex'))
    else:
        print "    slot %i - %s" % (slot, modhex_id)
    return public_id + 1


def print_job_description(args):
    print "YHSM device		: %s" % (args.device)
    print ""
    print "Will program :"
    print ""
    public_id = args.public_id
    for i in xrange(yubikeys_needed(args)):
        print "  YubiKey #%i :" % (i + 1)
        public_id = print_slot(args.slot_1, 1, public_id)
        if public_id < args.public_id + args.count:
            public_id = print_slot(args.slot_2, 2, public_id)
    print ""

def yubikeys_needed(args):
    """ Calculate how many YubiKey's will be needed. """
    num_keys = args.count
    if args.slot_1 and args.slot_2:
        num_keys = int(args.count / 2)
        num_keys += args.count % 2
    return num_keys

def print_slot(will_use, slot, public_id):
    """ Output a public id for a slot, if will_use is true. """
    if not will_use:
        return public_id
    this_id = pyhsm.yubikey.modhex_encode("%012x" % public_id)
    print "    slot %i - %s" % (slot, this_id)
    return public_id + 1

def main():
    args = parse_args()
    if not args:
        sys.exit(1)

    if not args.slot_1 and not args.slot_2:
        sys.stderr.write("Error: No slot(s) selected. Either -1, -2 or both must be supplied.\n")
        return 1

    if args.debug:
        print_job_description(args)

    status = program_yubikeys(args)

    sys.exit(status)

if __name__ == '__main__':
    main()
