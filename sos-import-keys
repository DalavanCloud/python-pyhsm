#!/usr/bin/env python
#
# Tool to import YubiKey secrets to Server on a Stick
#
# Copyright (c) 2011, Yubico AB
# All rights reserved.
#

import os
import re
import sys
import struct
import argparse
sys.path.append('Lib');
import serveronstick
import serveronstick.yubikey

#default_device = "/dev/serial/by-id/usb-Yubico_Yubico_ServerOnStick_498F517E3932-if00"
default_device = "/dev/ttyACM0"

def parse_args():
    """
    Parse the command line arguments
    """
    global default_device

    parser = argparse.ArgumentParser(description = "Generate secrets using Server on a Stick",
                                     add_help=True
                                     )
    parser.add_argument('-D', '--device',
                        dest='device',
                        default=default_device,
                        required=False,
                        help='Server-on-Stick device (default : %s).' % default_device
                        )
    parser.add_argument('-O', '--output-dir',
                        dest='output_dir',
                        default="/dev/shm/yubico/secrets",
                        required=False,
                        help='Output directory.'
                        )
    parser.add_argument('-v', '--verbose',
                        dest='verbose',
                        action='store_true', default=False,
                        help='Enable verbose operation.'
                        )
    parser.add_argument('--debug',
                        dest='debug',
                        action='store_true', default=False,
                        help='Enable debug operation.'
                        )
    parser.add_argument('--public-id-chars',
                        dest='public_id_chars',
                        type=int, default=12,
                        required=False,
                        help='Number of chars in generated public ids.'
                        )
    parser.add_argument('--key-handles',
                        dest='key_handles',
                        nargs='+',
                        required=True,
                        help='Key handles to encrypt the generated secrets with.'
                        )

    return parser.parse_args()

def args_fixup(args):
    if not os.path.isdir(args.output_dir):
        sys.stderr.write("Output directory '%s' does not exist.\n" % (args.output_dir))
        sys.exit(1)

    keyhandles_fixup(args)


def keyhandles_fixup(args):
    """
    Walk through the supplied key handles and normalize them, while keeping
    the input format too (as value in a dictionary). The input format is
    used in blob filename paths.
    """
    new_handles = {}
    for val in args.key_handles:
        for this in val.split(','):
            n = serveronstick.util.key_handle_to_int(this)
            new_handles[n] = this

    args.key_handles = new_handles


def import_keys(sos, args):
    """
    The main stdin iteration loop.
    """

    # ykksm 1
    #123456,ftftftcccc,534543524554,fcacd309a20ce1809c2db257f0e8d6ea,000000000000,,,

    for line in sys.stdin:
        l = line.split(',')
        modhex_id = l[1]
        uid = l[2].decode('hex')
        key = l[3].decode('hex')

        if modhex_id and uid and key:
            public_id = serveronstick.yubikey.modhex_decode(modhex_id)
            padded_id = modhex_id.rjust(args.public_id_chars, 'c')

        if args.verbose:
            print "  %s" % (padded_id)

        secret = serveronstick.secrets_cmd.SoS_Secrets(key, uid)
        #print "FREDRIK: LOAD SECRET PUBLIC_ID %s SECRET %s,%s" %(public_id, secret.uid.encode('hex'), secret.key.encode('hex'))
        sos.load_secret(public_id.decode('hex'), secret)

        for kh in args.key_handles.keys():
            #print "FREDRIK: GENERATING SECRET FOR KEY HANDLE %x" %(kh)
            blob = sos.generate_blob(kh)
            #print "FREDRIK: KH %s BLOB %s" % (kh, blob.blob.encode('hex'))
            filename = output_filename(args.output_dir, args.key_handles[kh], padded_id)

            if args.verbose:
                print "    %4s, %i bytes (%s) -> %s" % \
                    (args.key_handles[kh], len(blob.blob), shorten_blob(blob), filename)

            blob.save(filename)

        if args.verbose:
            print ""

    print "\nDone\n"

def shorten_blob(blob):
    head = blob.blob[:4].encode('hex')
    tail = blob.blob[-4:].encode('hex')
    return "%s...%s" % (head, tail)


def output_filename(output_dir, key_handle, public_id):
    """
    Return an output filename for a generated blob. Creates a hashed directory structure
    using the last three bytes of the public id to get equal usage.
    """

    path = os.path.join(output_dir, key_handle,
                        public_id[-1], public_id[-2], public_id[-3]
                        )

    if not os.path.isdir(path):
        os.makedirs(path)

    return os.path.join(path, public_id)



def main():
    args = parse_args()

    args_fixup(args)

    if sys.stdin.readline() != "# ykksm 1\n":
        sys.stderr.write("Did not get '# ykksm 1' header as first line of input.\n")
        sys.exit(1)

    print "output dir		: %s" % (args.output_dir)
    print "key handles		: %s" % (args.key_handles)
    print "SoS device		: %s" % (args.device)
    print ""

    sos = serveronstick.SoS(device = args.device, debug=args.debug)

    import_keys(sos, args)


if __name__ == '__main__':
    main()
